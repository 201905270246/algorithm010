**动态规划、状态转移方程串讲**
动态规划，递归，分治本质是寻找重复性：<br>
  1. 计算机指令集：for循环，while循环，递归调用，if等
  2. “最近”重复性：最大公约数
  3. 数学归纳法思维：同理可得
差异性是动态规划存在最有子结构，中途可以淘汰次优解
  
动态规划Dynamic Programming<br>
  1. 分解子问题
  2. 具有最有子结构
  3. 顺推形式：从下往上推动态递推
    ```
    function DP():
      dp = [][]  #DP状态方程，把现实的问题定义成一个数组（一维，二维，三维），里面保存状态
      
      for i = 0 .. M {
        for j = 0 .. N {
          dp[i][j] = _Function(dp[i'][j']...) # 状态转移方程，从之前的dp[i'][j']状态，推到最新的dp[i][j]的状态。
        }
      }
      
      return dp[M][N]         #反映最终结果
    ```
    
难点：<br>
  1. DP状态方程的定义
  2. 状态转移方程的写法：例如dp[i] = dp[i-1] + dp[i-2]；或者寻找最值；或者累加累减；或者有一层小循环，从之前的k个状态中找出最值。

**高级动态规划题目详解：**
  复杂度来源：
  1. 状态拥有更多维度（二维，三维。。。甚至需要压缩）
  2. 状态方程更加复杂
  
**高级字符串算法**
  最长公共子串
    dp[i][j] = dp[i-1][j-1] + 1 (if s1[i-1] == s2[j-1]) else dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  最长公共子序列
    dp[i][j] = dp[i-1][j-1] + 1 (if s1[i-1] == s2[j-1]) else dp[i][j] = 0

